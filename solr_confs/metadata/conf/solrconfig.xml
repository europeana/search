<?xml version="1.0" encoding="UTF-8" ?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<!--
     For more details about configurations options that may appear in
     this file, see http://wiki.apache.org/solr/SolrConfigXml.
-->
<config>
  <!-- In all configuration below, a prefix of "solr." for class names
       is an alias that causes solr to search appropriate packages,
       including org.apache.solr.(search|update|request|core|analysis)

       You may also specify a fully qualified Java classname if you
       have your own custom plugins.
    -->

  <!-- Controls what version of Lucene various components of Solr
       adhere to.  Generally, you want to use the latest version to
       get all bug fixes and improvements. It is highly recommended
       that you fully re-index after changing this setting as it can
       affect both how text is indexed and queried.
  -->
  <luceneMatchVersion>7.7.3</luceneMatchVersion>

  <!-- <lib/> directives can be used to instruct Solr to load any Jars
       identified and use them to resolve any "plugins" specified in
       your solrconfig.xml or schema.xml (ie: Analyzers, Request
       Handlers, etc...).

       All directories and paths are resolved relative to the
       instanceDir.

       Please note that <lib/> directives are processed in the order
       that they appear in your solrconfig.xml file, and are "stacked"
       on top of each other when building a ClassLoader - so if you have
       plugin jars with dependencies on other jars, the "lower level"
       dependency jars should be loaded first.

       If a "./lib" directory exists in your instanceDir, all files
       found in it are included as if you had used the following
       syntax...

              <lib dir="./lib" />
    -->

  <!-- A 'dir' option by itself adds any files found in the directory
       to the classpath, this is useful for including all jars in a
       directory.

       When a 'regex' is specified in addition to a 'dir', only the
       files in that directory which completely match the regex
       (anchored on both ends) will be included.

       If a 'dir' option (with or without a regex) is used and nothing
       is found that matches, a warning will be logged.

       The examples below can be used to load some solr-contribs along
       with their external dependencies.
    
  <lib dir="${solr.install.dir:../../../..}/contrib/extraction/lib" regex=".*\.jar" />
  <lib dir="${solr.install.dir:../../../..}/dist/" regex="solr-cell-\d.*\.jar" />

  <lib dir="${solr.install.dir:../../../..}/contrib/clustering/lib/" regex=".*\.jar" />
  <lib dir="${solr.install.dir:../../../..}/dist/" regex="solr-clustering-\d.*\.jar" />

  <lib dir="${solr.install.dir:../../../..}/contrib/langid/lib/" regex=".*\.jar" />
  <lib dir="${solr.install.dir:../../../..}/dist/" regex="solr-langid-\d.*\.jar" />
  -->

  <!-- mmarrero: adding directive to load alias plugin -->
  <lib dir="${solr.install.dir:../../../..}/contrib/lib" regex=".*\.jar" />
  <!-- mmarrero: adding directive to load additional libraries for language normalization -->
  <lib dir="${solr.install.dir:../../../..}/contrib/analysis-extras/lucene-libs" regex=".*\.jar" />
  

  <!-- an exact 'path' can be used instead of a 'dir' to specify a
       specific jar file.  This will cause a serious error to be logged
       if it can't be loaded.
    -->
  <!--
     <lib path="../a-jar-that-does-not-exist.jar" />
  -->

  <!-- Data Directory

       Used to specify an alternate directory to hold all index data
       other than the default ./data under the Solr home.  If
       replication is in use, this should match the replication
       configuration.
    -->
  <dataDir>${solr.data.dir:}</dataDir>


  <!-- The DirectoryFactory to use for indexes.

       solr.StandardDirectoryFactory is filesystem
       based and tries to pick the best implementation for the current
       JVM and platform.  solr.NRTCachingDirectoryFactory, the default,
       wraps solr.StandardDirectoryFactory and caches small files in memory
       for better NRT performance.

       One can force a particular implementation via solr.MMapDirectoryFactory,
       solr.NIOFSDirectoryFactory, or solr.SimpleFSDirectoryFactory.

       solr.RAMDirectoryFactory is memory based and not persistent.
    -->
  <directoryFactory name="DirectoryFactory"
                    class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>

  <!-- The CodecFactory for defining the format of the inverted index.
       The default implementation is SchemaCodecFactory, which is the official Lucene
       index format, but hooks into the schema to provide per-field customization of
       the postings lists and per-document values in the fieldType element
       (postingsFormat/docValuesFormat). Note that most of the alternative implementations
       are experimental, so if you choose to customize the index format, it's a good
       idea to convert back to the official format e.g. via IndexWriter.addIndexes(IndexReader)
       before upgrading to a newer version to avoid unnecessary reindexing.
       A "compressionMode" string element can be added to <codecFactory> to choose
       between the existing compression modes in the default codec: "BEST_SPEED" (default)
       or "BEST_COMPRESSION".
  -->
  <codecFactory class="solr.SchemaCodecFactory"/>

  <!-- mmarrero: preventing managed schemas -->
  <schemaFactory class="ClassicIndexSchemaFactory"/>

  <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Index Config - These settings control low-level behavior of indexing
       Most example settings here show the default value, but are commented
       out, to more easily see where customizations have been made.

       Note: This replaces <indexDefaults> and <mainIndex> from older versions
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  <indexConfig>
    <!-- maxFieldLength was removed in 4.0. To get similar behavior, include a
         LimitTokenCountFilterFactory in your fieldType definition. E.g.
     <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="10000"/>
    -->
    <!-- Maximum time to wait for a write lock (ms) for an IndexWriter. Default: 1000 -->
    <!-- <writeLockTimeout>1000</writeLockTimeout>  -->

    <!-- Expert: Enabling compound file will use less files for the index,
         using fewer file descriptors on the expense of performance decrease.
         Default in Lucene is "true". Default in Solr is "false" (since 3.6) -->
    <!-- <useCompoundFile>false</useCompoundFile> -->

    <!-- ramBufferSizeMB sets the amount of RAM that may be used by Lucene
         indexing for buffering added documents and deletions before they are
         flushed to the Directory.
         maxBufferedDocs sets a limit on the number of documents buffered
         before flushing.
         If both ramBufferSizeMB and maxBufferedDocs is set, then
         Lucene will flush based on whichever limit is hit first.  -->
    <!-- <ramBufferSizeMB>100</ramBufferSizeMB> -->
    <!-- <maxBufferedDocs>1000</maxBufferedDocs> -->

    <!-- Expert: Merge Policy
         The Merge Policy in Lucene controls how merging of segments is done.
         The default since Solr/Lucene 3.3 is TieredMergePolicy.
         The default since Lucene 2.3 was the LogByteSizeMergePolicy,
         Even older versions of Lucene used LogDocMergePolicy.
      -->
    <!--
        <mergePolicyFactory class="org.apache.solr.index.TieredMergePolicyFactory">
          <int name="maxMergeAtOnce">10</int>
          <int name="segmentsPerTier">10</int>
          <double name="noCFSRatio">0.1</double>
        </mergePolicyFactory>
      -->

    <!-- Expert: Merge Scheduler
         The Merge Scheduler in Lucene controls how merges are
         performed.  The ConcurrentMergeScheduler (Lucene 2.3 default)
         can perform merges in the background using separate threads.
         The SerialMergeScheduler (Lucene 2.2 default) does not.
     -->
    <!--
       <mergeScheduler class="org.apache.lucene.index.ConcurrentMergeScheduler"/>
       -->

    <!-- LockFactory

         This option specifies which Lucene LockFactory implementation
         to use.

         single = SingleInstanceLockFactory - suggested for a
                  read-only index or when there is no possibility of
                  another process trying to modify the index.
         native = NativeFSLockFactory - uses OS native file locking.
                  Do not use when multiple solr webapps in the same
                  JVM are attempting to share a single index.
         simple = SimpleFSLockFactory  - uses a plain file for locking

         Defaults: 'native' is default for Solr3.6 and later, otherwise
                   'simple' is the default

         More details on the nuances of each LockFactory...
         http://wiki.apache.org/lucene-java/AvailableLockFactories
    -->
    <lockType>${solr.lock.type:native}</lockType>

    <!-- Commit Deletion Policy
         Custom deletion policies can be specified here. The class must
         implement org.apache.lucene.index.IndexDeletionPolicy.

         The default Solr IndexDeletionPolicy implementation supports
         deleting index commit points on number of commits, age of
         commit point and optimized status.

         The latest commit point should always be preserved regardless
         of the criteria.
    -->
    <!--
    <deletionPolicy class="solr.SolrDeletionPolicy">
    -->
    <!-- The number of commit points to be kept -->
    <!-- <str name="maxCommitsToKeep">1</str> -->
    <!-- The number of optimized commit points to be kept -->
    <!-- <str name="maxOptimizedCommitsToKeep">0</str> -->
    <!--
        Delete all commit points once they have reached the given age.
        Supports DateMathParser syntax e.g.
      -->
    <!--
       <str name="maxCommitAge">30MINUTES</str>
       <str name="maxCommitAge">1DAY</str>
    -->
    <!--
    </deletionPolicy>
    -->

    <!-- Lucene Infostream

         To aid in advanced debugging, Lucene provides an "InfoStream"
         of detailed information when indexing.

         Setting The value to true will instruct the underlying Lucene
         IndexWriter to write its debugging info the specified file
      -->
    <!-- <infoStream file="INFOSTREAM.txt">false</infoStream> -->
  </indexConfig>


  <!-- JMX

       This example enables JMX if and only if an existing MBeanServer
       is found, use this if you want to configure JMX through JVM
       parameters. Remove this to disable exposing Solr configuration
       and statistics to JMX.

       For more details see http://wiki.apache.org/solr/SolrJmx
    -->
  <jmx />
  <!-- If you want to connect to a particular server, specify the
       agentId
    -->
  <!-- <jmx agentId="myAgent" /> -->
  <!-- If you want to start a new MBeanServer, specify the serviceUrl -->
  <!-- <jmx serviceUrl="service:jmx:rmi:///jndi/rmi://localhost:9999/solr"/>
    -->

  <!-- The default high-performance update handler -->
  <updateHandler class="solr.DirectUpdateHandler2">

    <!-- Enables a transaction log, used for real-time get, durability, and
         and solr cloud replica recovery.  The log can grow as big as
         uncommitted changes to the index, so use of a hard autoCommit
         is recommended (see below).
         "dir" - the target directory for transaction logs, defaults to the
                solr data directory.
         "numVersionBuckets" - sets the number of buckets used to keep
                track of max version values when checking for re-ordered
                updates; increase this value to reduce the cost of
                synchronizing access to version buckets during high-volume
                indexing, this requires 8 bytes (long) * numVersionBuckets
                of heap space per Solr core.
    -->
    <updateLog>
      <str name="dir">${solr.ulog.dir:}</str>
      <int name="numVersionBuckets">${solr.ulog.numVersionBuckets:65536}</int>
    </updateLog>

    <!-- AutoCommit

         Perform a hard commit automatically under certain conditions.
         Instead of enabling autoCommit, consider using "commitWithin"
         when adding documents.

         http://wiki.apache.org/solr/UpdateXmlMessages

         maxDocs - Maximum number of documents to add since the last
                   commit before automatically triggering a new commit.

         maxTime - Maximum amount of time in ms that is allowed to pass
                   since a document was added before automatically
                   triggering a new commit.
         openSearcher - if false, the commit causes recent index changes
           to be flushed to stable storage, but does not cause a new
           searcher to be opened to make those changes visible.

         If the updateLog is enabled, then it's highly recommended to
         have some sort of hard autoCommit to limit the log size.
      -->

    <autoCommit>
      <maxTime>${solr.autoCommit.maxTime:60000}</maxTime>
      <openSearcher>false</openSearcher>
    </autoCommit>

    <!-- softAutoCommit is like autoCommit except it causes a
         'soft' commit which only ensures that changes are visible
         but does not ensure that data is synced to disk.  This is
         faster and more near-realtime friendly than a hard commit.
      -->

    <autoSoftCommit>
      <maxTime>${solr.autoSoftCommit.maxTime:900000}</maxTime>
    </autoSoftCommit>

    <!-- Update Related Event Listeners

         Various IndexWriter related events can trigger Listeners to
         take actions.

         postCommit - fired after every commit or optimize command
         postOptimize - fired after every optimize command
      -->

  </updateHandler>

  <!-- IndexReaderFactory

       Use the following format to specify a custom IndexReaderFactory,
       which allows for alternate IndexReader implementations.

       ** Experimental Feature **

       Please note - Using a custom IndexReaderFactory may prevent
       certain other features from working. The API to
       IndexReaderFactory may change without warning or may even be
       removed from future releases if the problems cannot be
       resolved.


       ** Features that may not work with custom IndexReaderFactory **

       The ReplicationHandler assumes a disk-resident index. Using a
       custom IndexReader implementation may cause incompatibility
       with ReplicationHandler and may cause replication to not work
       correctly. See SOLR-1366 for details.

    -->
  <!--
  <indexReaderFactory name="IndexReaderFactory" class="package.class">
    <str name="someArg">Some Value</str>
  </indexReaderFactory >
  -->

  <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Query section - these settings control query time things like caches
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  <query>

    <!-- Maximum number of clauses in each BooleanQuery,  an exception
         is thrown if exceeded.  It is safe to increase or remove this setting,
         since it is purely an arbitrary limit to try and catch user errors where
         large boolean queries may not be the best implementation choice.
      -->
    <maxBooleanClauses>${solr.max.booleanClauses:1024}</maxBooleanClauses>

    <!-- Solr Internal Query Caches

         There are two implementations of cache available for Solr,
         LRUCache, based on a synchronized LinkedHashMap, and
         FastLRUCache, based on a ConcurrentHashMap.

         FastLRUCache has faster gets and slower puts in single
         threaded operation and thus is generally faster than LRUCache
         when the hit ratio of the cache is high (> 75%), and may be
         faster under other scenarios on multi-cpu systems.
    -->

    <!-- Filter Cache

         Cache used by SolrIndexSearcher for filters (DocSets),
         unordered sets of *all* documents that match a query.  When a
         new searcher is opened, its caches may be prepopulated or
         "autowarmed" using data from caches in the old searcher.
         autowarmCount is the number of items to prepopulate.  For
         LRUCache, the autowarmed items will be the most recently
         accessed items.

         Parameters:
           class - the SolrCache implementation LRUCache or
               (LRUCache or FastLRUCache)
           size - the maximum number of entries in the cache
           initialSize - the initial capacity (number of entries) of
               the cache.  (see java.util.HashMap)
           autowarmCount - the number of entries to prepopulate from
               and old cache.
           maxRamMB - the maximum amount of RAM (in MB) that this cache is allowed
                      to occupy. Note that when this option is specified, the size
                      and initialSize parameters are ignored.
      -->
    <filterCache class="solr.FastLRUCache"
                 size="512"
                 initialSize="512"
                 autowarmCount="256"/>

    <!-- Query Result Cache

         Caches results of searches - ordered lists of document ids
         (DocList) based on a query, a sort, and the range of documents requested.
         Additional supported parameter by LRUCache:
            maxRamMB - the maximum amount of RAM (in MB) that this cache is allowed
                       to occupy
      -->
    <queryResultCache class="solr.LRUCache"
                      size="512"
                      initialSize="512"
                      autowarmCount="0"/>

    <!-- Document Cache

         Caches Lucene Document objects (the stored fields for each
         document).  Since Lucene internal document ids are transient,
         this cache will not be autowarmed.
      -->
    <documentCache class="solr.LRUCache"
                   size="512"
                   initialSize="512"
                   autowarmCount="0"/>

    <!-- custom cache currently used by block join -->
    <cache name="perSegFilter"
           class="solr.search.LRUCache"
           size="10"
           initialSize="0"
           autowarmCount="10"
           regenerator="solr.NoOpRegenerator" />

    <!-- Field Value Cache

         Cache used to hold field values that are quickly accessible
         by document id.  The fieldValueCache is created by default
         even if not configured here.
      -->
    <!--
       <fieldValueCache class="solr.FastLRUCache"
                        size="512"
                        autowarmCount="128"
                        showItems="32" />
      -->

    <!-- Custom Cache

         Example of a generic cache.  These caches may be accessed by
         name through SolrIndexSearcher.getCache(),cacheLookup(), and
         cacheInsert().  The purpose is to enable easy caching of
         user/application level data.  The regenerator argument should
         be specified as an implementation of solr.CacheRegenerator
         if autowarming is desired.
      -->
    <!--
       <cache name="myUserCache"
              class="solr.LRUCache"
              size="4096"
              initialSize="1024"
              autowarmCount="1024"
              regenerator="com.mycompany.MyRegenerator"
              />
      -->


    <!-- Lazy Field Loading

         If true, stored fields that are not requested will be loaded
         lazily.  This can result in a significant speed improvement
         if the usual case is to not load all stored fields,
         especially if the skipped fields are large compressed text
         fields.
    -->
    <enableLazyFieldLoading>true</enableLazyFieldLoading>

    <!-- Use Filter For Sorted Query

         A possible optimization that attempts to use a filter to
         satisfy a search.  If the requested sort does not include
         score, then the filterCache will be checked for a filter
         matching the query. If found, the filter will be used as the
         source of document ids, and then the sort will be applied to
         that.

         For most situations, this will not be useful unless you
         frequently get the same search repeatedly with different sort
         options, and none of them ever use "score"
      -->
    <!--
       <useFilterForSortedQuery>true</useFilterForSortedQuery>
      -->

    <!-- Result Window Size

         An optimization for use with the queryResultCache.  When a search
         is requested, a superset of the requested number of document ids
         are collected.  For example, if a search for a particular query
         requests matching documents 10 through 19, and queryWindowSize is 50,
         then documents 0 through 49 will be collected and cached.  Any further
         requests in that range can be satisfied via the cache.
      -->
    <queryResultWindowSize>96</queryResultWindowSize>

    <!-- Maximum number of documents to cache for any entry in the
         queryResultCache.
      -->
    <queryResultMaxDocsCached>960</queryResultMaxDocsCached>

    <!-- Query Related Event Listeners

         Various IndexSearcher related events can trigger Listeners to
         take actions.

         newSearcher - fired whenever a new searcher is being prepared
         and there is a current searcher handling requests (aka
         registered).  It can be used to prime certain caches to
         prevent long request times for certain requests.

         firstSearcher - fired whenever a new searcher is being
         prepared but there is no current registered searcher to handle
         requests or to gain autowarming data from.


      -->
    <!-- QuerySenderListener takes an array of NamedList and executes a
         local query request for each NamedList in sequence.
      -->
    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
          <!-- mmarrero: TODO: check and add rights -->
        <!--
           <lst><str name="q">solr</str><str name="sort">price asc</str></lst>
           <lst><str name="q">rocks</str><str name="sort">weight asc</str></lst>
          -->
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, random_europeana asc, timestamp_update desc, id asc</str>
          <str name="facet.field">provider_id</str>
          <str name="facet.field">dataProvider_id</str>
          <str name="facet.limit">125000</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, metadataQuality desc, timestamp_update desc, id asc</str>
          <str name="facet.field">provider_id</str>
          <str name="facet.field">dataProvider_id</str>
          <str name="facet.limit">125000</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, random_europeana asc, timestamp_update desc, id asc</str>
          <str name="facet.field">facet_tags</str>          
          <str name="facet.field">metadataLanguage</str>          
          <str name="facet.field">country_id</str>          
          <str name="facet.limit">750</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, metadataQuality desc, timestamp_update desc, id asc</str>
          <str name="facet.field">facet_tags</str>
          <str name="facet.field">metadataLanguage</str>          
          <str name="facet.field">country_id</str>          
          <str name="facet.limit">750</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="fq">collection:archaeology</str>
        </lst>
        <lst>
          <str name="fq">collection:art</str>
        </lst>
        <lst>
          <str name="fq">collection:fashion</str>
        </lst>
        <lst>
          <str name="fq">collection:manuscript</str>
        </lst>
        <lst>
          <str name="fq">collection:map</str>
        </lst>
        <lst>
          <str name="fq">collection:migration</str>
        </lst>
        <lst>
          <str name="fq">collection:music</str>
        </lst>
        <lst>
          <str name="fq">collection:nature</str>
        </lst>
        <lst>
          <str name="fq">collection:newspaper</str>
        </lst>
        <lst>
          <str name="fq">collection:photography</str>
        </lst>
        <lst>
          <str name="fq">collection:sport</str>
        </lst>
        <lst> 
          <str name="fq">collection:ww1</str>
        </lst>
        <lst> 
          <str name="fq">collection:industrial</str>
        </lst>
        <lst> 
          <str name="fq">collection:ccsearch</str>
        </lst>
        <lst> 
          <str name="fq">contentTier:(2 OR 3 OR 4)</str>
        </lst>
        <lst> 
          <str name="fq">contentTier:(1 OR 2 OR 3 OR 4)</str>
        </lst>
        <!--  Reusability options used in portal as 'open' -->
       
      </arr>
    </listener>
    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
          <!-- mmarrero: TODO: check and add rights -->
        <!--
        <lst>
          <str name="q">static firstSearcher warming in solrconfig.xml</str>
        </lst>
        -->
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, random_europeana asc, timestamp_update desc, id asc</str>
          <str name="facet.field">provider_id</str>
          <str name="facet.field">dataProvider_id</str>
          <str name="facet.limit">125000</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, metadataQuality desc, timestamp_update desc, id asc</str>
          <str name="facet.field">provider_id</str>
          <str name="facet.field">dataProvider_id</str>
          <str name="facet.limit">125000</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, random_europeana asc, timestamp_update desc, id asc</str>
          <str name="facet.field">facet_tags</str>          
          <str name="facet.field">metadataLanguage</str>          
          <str name="facet.field">country_id</str>          
          <str name="facet.limit">750</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="q">*:*</str>
          <str name="sort">score desc, contentQuality desc, metadataQuality desc, timestamp_update desc, id asc</str>
          <str name="facet.field">facet_tags</str>
          <str name="facet.field">metadataLanguage</str>          
          <str name="facet.field">country_id</str>          
          <str name="facet.limit">750</str>
          <str name="rows">24</str>
        </lst>
        <lst>
          <str name="fq">collection:archaeology</str>
        </lst>
        <lst>
          <str name="fq">collection:art</str>
        </lst>
        <lst>
          <str name="fq">collection:fashion</str>
        </lst>
        <lst>
          <str name="fq">collection:manuscript</str>
        </lst>
        <lst>
          <str name="fq">collection:map</str>
        </lst>
        <lst>
          <str name="fq">collection:migration</str>
        </lst>
        <lst>
          <str name="fq">collection:music</str>
        </lst>
        <lst>
          <str name="fq">collection:nature</str>
        </lst>
        <lst>
          <str name="fq">collection:newspaper</str>
        </lst>
        <lst>
          <str name="fq">collection:photography</str>
        </lst>
        <lst>
          <str name="fq">collection:sport</str>
        </lst>
        <lst> 
          <str name="fq">collection:ww1</str>
        </lst>
        <lst> 
          <str name="fq">collection:industrial</str>
        </lst>
        <lst> 
          <str name="fq">collection:ccsearch</str>
        </lst>
        <lst> 
          <str name="fq">contentTier:(2 OR 3 OR 4)</str>
        </lst>
        <lst> 
          <str name="fq">contentTier:(1 OR 2 OR 3 OR 4)</str>
        </lst>
        <!--  Reusability options used in portal as 'open' -->
       
      </arr>
    </listener>

    <!-- Use Cold Searcher

         If a search request comes in and there is no current
         registered searcher, then immediately register the still
         warming searcher and use it.  If "false" then all requests
         will block until the first searcher is done warming.
      -->
    <useColdSearcher>true</useColdSearcher>

    <!-- mmarrero: adding this option as it is not clear 2 is the default -->
    <maxWarmingSearchers>2</maxWarmingSearchers>

  </query>


  <!-- Request Dispatcher

       This section contains instructions for how the SolrDispatchFilter
       should behave when processing requests for this SolrCore.

    -->
  <requestDispatcher>
    <!-- Request Parsing

         These settings indicate how Solr Requests may be parsed, and
         what restrictions may be placed on the ContentStreams from
         those requests

         enableRemoteStreaming - enables use of the stream.file
         and stream.url parameters for specifying remote streams.

         multipartUploadLimitInKB - specifies the max size (in KiB) of
         Multipart File Uploads that Solr will allow in a Request.

         formdataUploadLimitInKB - specifies the max size (in KiB) of
         form data (application/x-www-form-urlencoded) sent via
         POST. You can use POST to pass request parameters not
         fitting into the URL.

         addHttpRequestToContext - if set to true, it will instruct
         the requestParsers to include the original HttpServletRequest
         object in the context map of the SolrQueryRequest under the
         key "httpRequest". It will not be used by any of the existing
         Solr components, but may be useful when developing custom
         plugins.

         *** WARNING ***
         Before enabling remote streaming, you should make sure your
         system has authentication enabled.

     -->
    <requestParsers enableRemoteStreaming="true"
                    multipartUploadLimitInKB="2048000"
                    formdataUploadLimitInKB="2048"
                    addHttpRequestToContext="false"/>
      

    <!-- HTTP Caching

         Set HTTP caching related parameters (for proxy caches and clients).

         The options below instruct Solr not to output any HTTP Caching
         related headers
      -->
    <httpCaching never304="true" />
    <!-- If you include a <cacheControl> directive, it will be used to
         generate a Cache-Control header (as well as an Expires header
         if the value contains "max-age=")

         By default, no Cache-Control header is generated.

         You can use the <cacheControl> option even if you have set
         never304="true"
      -->
    <!--
       <httpCaching never304="true" >
         <cacheControl>max-age=30, public</cacheControl>
       </httpCaching>
      -->
    <!-- To enable Solr to respond with automatically generated HTTP
         Caching headers, and to response to Cache Validation requests
         correctly, set the value of never304="false"

         This will cause Solr to generate Last-Modified and ETag
         headers based on the properties of the Index.

         The following options can also be specified to affect the
         values of these headers...

         lastModFrom - the default value is "openTime" which means the
         Last-Modified value (and validation against If-Modified-Since
         requests) will all be relative to when the current Searcher
         was opened.  You can change it to lastModFrom="dirLastMod" if
         you want the value to exactly correspond to when the physical
         index was last modified.

         etagSeed="..." is an option you can change to force the ETag
         header (and validation against If-None-Match requests) to be
         different even if the index has not changed (ie: when making
         significant changes to your config file)

         (lastModifiedFrom and etagSeed are both ignored if you use
         the never304="true" option)
      -->
    <!--
       <httpCaching lastModifiedFrom="openTime"
                    etagSeed="Solr">
         <cacheControl>max-age=30, public</cacheControl>
       </httpCaching>
      -->
  </requestDispatcher>

  <!-- Request Handlers

       http://wiki.apache.org/solr/SolrRequestHandler

       Incoming queries will be dispatched to a specific handler by name
       based on the path specified in the request.

       If a Request Handler is declared with startup="lazy", then it will
       not be initialized until the first request that uses it.

    -->

    <!-- mmarrero: removing all handlers given as examples, check in default config in Solr 7.7.3 -->

    <!-- mmarrero: default search handler using the alias plugin -->
    <requestHandler name="/select" class="solr.AliasingSearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
       <str name="q.op">AND</str>
       <str name="defType">edismax</str>
       <str name="qf">metadataText_lang_undef metadataText_lang_other metadataText_lang_en metadataText_lang_nl metadataText_lang_fr metadataText_lang_de metadataText_lang_es metadataText_lang_sv metadataText_lang_it metadataText_lang_fi metadataText_lang_da metadataText_lang_da metadataText_lang_el metadataText_lang_cs metadataText_lang_sk metadataText_lang_sl metadataText_lang_pt metadataText_lang_hu metadataText_lang_lt metadataText_lang_pl metadataText_lang_ro metadataText_lang_bg metadataText_lang_hr metadataText_lang_lv metadataText_lang_ga metadataText_lang_mt metadataText_lang_et metadataText_lang_eu</str> <!-- replaces df -->
       <str name="tie">0.1</str>
       <!-- mmarrero: test if general search can be done using language specific normalization, if performance is bad, then use fields with standard normalization -->
       <str name="f.title.qf">title_lang_undef title_lang_other title_lang_en title_lang_nl title_lang_fr title_lang_de title_lang_es title_lang_sv title_lang_it title_lang_fi title_lang_da title_lang_da title_lang_el title_lang_cs title_lang_sk title_lang_sl title_lang_pt title_lang_hu title_lang_lt title_lang_pl title_lang_ro title_lang_bg title_lang_hr title_lang_lv title_lang_ga title_lang_mt title_lang_et title_lang_eu</str>
        <str name="f.description.qf">description_lang_undef description_lang_other description_lang_en description_lang_nl description_lang_fr description_lang_de description_lang_es description_lang_sv description_lang_it description_lang_fi description_lang_da description_lang_da description_lang_el description_lang_cs description_lang_sk description_lang_sl description_lang_pt description_lang_hu description_lang_lt description_lang_pl description_lang_ro description_lang_bg description_lang_hr description_lang_lv description_lang_ga description_lang_mt description_lang_et description_lang_eu</str>
         <str name="f.titlePlus.qf">titlePlus_lang_undef titlePlus_lang_other titlePlus_lang_en titlePlus_lang_nl titlePlus_lang_fr titlePlus_lang_de titlePlus_lang_es titlePlus_lang_sv titlePlus_lang_it titlePlus_lang_fi titlePlus_lang_da titlePlus_lang_da titlePlus_lang_el titlePlus_lang_cs titlePlus_lang_sk titlePlus_lang_sl titlePlus_lang_pt titlePlus_lang_hu titlePlus_lang_lt titlePlus_lang_pl titlePlus_lang_ro titlePlus_lang_bg titlePlus_lang_hr titlePlus_lang_lv titlePlus_lang_ga titlePlus_lang_mt titlePlus_lang_et titlePlus_lang_eu</str>

        <str name="f.creator.qf">creator_lang_undef creator_lang_other creator_lang_en creator_lang_nl creator_lang_fr creator_lang_de creator_lang_es creator_lang_sv creator_lang_it creator_lang_fi creator_lang_da creator_lang_da creator_lang_el creator_lang_cs creator_lang_sk creator_lang_sl creator_lang_pt creator_lang_hu creator_lang_lt creator_lang_pl creator_lang_ro creator_lang_bg creator_lang_hr creator_lang_lv creator_lang_ga creator_lang_mt creator_lang_et creator_lang_eu</str>
        <str name="f.creatorProfession.qf">creatorProfession_lang_undef creatorProfession_lang_other creatorProfession_lang_en creatorProfession_lang_nl creatorProfession_lang_fr creatorProfession_lang_de creatorProfession_lang_es creatorProfession_lang_sv creatorProfession_lang_it creatorProfession_lang_fi creatorProfession_lang_da creatorProfession_lang_da creatorProfession_lang_el creatorProfession_lang_cs creatorProfession_lang_sk creatorProfession_lang_sl creatorProfession_lang_pt creatorProfession_lang_hu creatorProfession_lang_lt creatorProfession_lang_pl creatorProfession_lang_ro creatorProfession_lang_bg creatorProfession_lang_hr creatorProfession_lang_lv creatorProfession_lang_ga creatorProfession_lang_mt creatorProfession_lang_et creatorProfession_lang_eu</str>
         <str name="f.who.qf">who_lang_undef who_lang_other who_lang_en who_lang_nl who_lang_fr who_lang_de who_lang_es who_lang_sv who_lang_it who_lang_fi who_lang_da who_lang_da who_lang_el who_lang_cs who_lang_sk who_lang_sl who_lang_pt who_lang_hu who_lang_lt who_lang_pl who_lang_ro who_lang_bg who_lang_hr who_lang_lv who_lang_ga who_lang_mt who_lang_et who_lang_eu</str>
        <str name="f.who_id.qf">creator_id creatorProfession_id</str>
        
        <str name="f.objectType.qf">objectType_lang_undef objectType_lang_other objectType_lang_en objectType_lang_nl objectType_lang_fr objectType_lang_de objectType_lang_es objectType_lang_sv objectType_lang_it objectType_lang_fi objectType_lang_da objectType_lang_da objectType_lang_el objectType_lang_cs objectType_lang_sk objectType_lang_sl objectType_lang_pt objectType_lang_hu objectType_lang_lt objectType_lang_pl objectType_lang_ro objectType_lang_bg objectType_lang_hr objectType_lang_lv objectType_lang_ga objectType_lang_mt objectType_lang_et objectType_lang_eu</str>
        <str name="f.subject.qf">subject_lang_undef subject_lang_other subject_lang_en subject_lang_nl subject_lang_fr subject_lang_de subject_lang_es subject_lang_sv subject_lang_it subject_lang_fi subject_lang_da subject_lang_da subject_lang_el subject_lang_cs subject_lang_sk subject_lang_sl subject_lang_pt subject_lang_hu subject_lang_lt subject_lang_pl subject_lang_ro subject_lang_bg subject_lang_hr subject_lang_lv subject_lang_ga subject_lang_mt subject_lang_et subject_lang_eu</str>
        <str name="f.format.qf">format_lang_undef format_lang_other format_lang_en format_lang_nl format_lang_fr format_lang_de format_lang_es format_lang_sv format_lang_it format_lang_fi format_lang_da format_lang_da format_lang_el format_lang_cs format_lang_sk format_lang_sl format_lang_pt format_lang_hu format_lang_lt format_lang_pl format_lang_ro format_lang_bg format_lang_hr format_lang_lv format_lang_ga format_lang_mt format_lang_et format_lang_eu</str>
        <str name="f.medium.qf">medium_lang_undef medium_lang_other medium_lang_en medium_lang_nl medium_lang_fr medium_lang_de medium_lang_es medium_lang_sv medium_lang_it medium_lang_fi medium_lang_da medium_lang_da medium_lang_el medium_lang_cs medium_lang_sk medium_lang_sl medium_lang_pt medium_lang_hu medium_lang_lt medium_lang_pl medium_lang_ro medium_lang_bg medium_lang_hr medium_lang_lv medium_lang_ga medium_lang_mt medium_lang_et medium_lang_eu</str>
        <str name="f.what.qf">what_lang_undef what_lang_other what_lang_en what_lang_nl what_lang_fr what_lang_de what_lang_es what_lang_sv what_lang_it what_lang_fi what_lang_da what_lang_da what_lang_el what_lang_cs what_lang_sk what_lang_sl what_lang_pt what_lang_hu what_lang_lt what_lang_pl what_lang_ro what_lang_bg what_lang_hr what_lang_lv what_lang_ga what_lang_mt what_lang_et what_lang_eu</str>
        <str name="f.what_id.qf">objectType_id subject_id medium_id format_id</str>
        
        <str name="f.created.qf">created_lang_undef created_lang_other created_lang_en created_lang_nl created_lang_fr created_lang_de created_lang_es created_lang_sv created_lang_it created_lang_fi created_lang_da created_lang_da created_lang_el created_lang_cs created_lang_sk created_lang_sl created_lang_pt created_lang_hu created_lang_lt created_lang_pl created_lang_ro created_lang_bg created_lang_hr created_lang_lv created_lang_ga created_lang_mt created_lang_et created_lang_eu</str>
        <str name="f.issued.qf">issued_lang_undef issued_lang_other issued_lang_en issued_lang_nl issued_lang_fr issued_lang_de issued_lang_es issued_lang_sv issued_lang_it issued_lang_fi issued_lang_da issued_lang_da issued_lang_el issued_lang_cs issued_lang_sk issued_lang_sl issued_lang_pt issued_lang_hu issued_lang_lt issued_lang_pl issued_lang_ro issued_lang_bg issued_lang_hr issued_lang_lv issued_lang_ga issued_lang_mt issued_lang_et issued_lang_eu</str>
        <str name="f.temporalCoverage.qf">temporalCoverage_lang_undef temporalCoverage_lang_other temporalCoverage_lang_en temporalCoverage_lang_nl temporalCoverage_lang_fr temporalCoverage_lang_de temporalCoverage_lang_es temporalCoverage_lang_sv temporalCoverage_lang_it temporalCoverage_lang_fi temporalCoverage_lang_da temporalCoverage_lang_da temporalCoverage_lang_el temporalCoverage_lang_cs temporalCoverage_lang_sk temporalCoverage_lang_sl temporalCoverage_lang_pt temporalCoverage_lang_hu temporalCoverage_lang_lt temporalCoverage_lang_pl temporalCoverage_lang_ro temporalCoverage_lang_bg temporalCoverage_lang_hr temporalCoverage_lang_lv temporalCoverage_lang_ga temporalCoverage_lang_mt temporalCoverage_lang_et temporalCoverage_lang_eu</str>
        <str name="f.when.qf">when_lang_undef when_lang_other when_lang_en when_lang_nl when_lang_fr when_lang_de when_lang_es when_lang_sv when_lang_it when_lang_fi when_lang_da when_lang_da when_lang_el when_lang_cs when_lang_sk when_lang_sl when_lang_pt when_lang_hu when_lang_lt when_lang_pl when_lang_ro when_lang_bg when_lang_hr when_lang_lv when_lang_ga when_lang_mt when_lang_et when_lang_eu</str>
        <str name="f.when_id.qf">created_id issued_id temporalCoverage_id</str>
        
		<str name="f.providingCountry.qf">providingCountry_lang_undef providingCountry_lang_other providingCountry_lang_en providingCountry_lang_nl providingCountry_lang_fr providingCountry_lang_de providingCountry_lang_es providingCountry_lang_sv providingCountry_lang_it providingCountry_lang_fi providingCountry_lang_da providingCountry_lang_da providingCountry_lang_el providingCountry_lang_cs providingCountry_lang_sk providingCountry_lang_sl providingCountry_lang_pt providingCountry_lang_hu providingCountry_lang_lt providingCountry_lang_pl providingCountry_lang_ro providingCountry_lang_bg providingCountry_lang_hr providingCountry_lang_lv providingCountry_lang_ga providingCountry_lang_mt providingCountry_lang_et providingCountry_lang_eu</str>        
        <str name="f.currentLocation.qf">currentLocation_lang_undef currentLocation_lang_other currentLocation_lang_en currentLocation_lang_nl currentLocation_lang_fr currentLocation_lang_de currentLocation_lang_es currentLocation_lang_sv currentLocation_lang_it currentLocation_lang_fi currentLocation_lang_da currentLocation_lang_da currentLocation_lang_el currentLocation_lang_cs currentLocation_lang_sk currentLocation_lang_sl currentLocation_lang_pt currentLocation_lang_hu currentLocation_lang_lt currentLocation_lang_pl currentLocation_lang_ro currentLocation_lang_bg currentLocation_lang_hr currentLocation_lang_lv currentLocation_lang_ga currentLocation_lang_mt currentLocation_lang_et currentLocation_lang_eu</str>
		<str name="f.spatialCoverage.qf">spatialCoverage_lang_undef spatialCoverage_lang_other spatialCoverage_lang_en spatialCoverage_lang_nl spatialCoverage_lang_fr spatialCoverage_lang_de spatialCoverage_lang_es spatialCoverage_lang_sv spatialCoverage_lang_it spatialCoverage_lang_fi spatialCoverage_lang_da spatialCoverage_lang_da spatialCoverage_lang_el spatialCoverage_lang_cs spatialCoverage_lang_sk spatialCoverage_lang_sl spatialCoverage_lang_pt spatialCoverage_lang_hu spatialCoverage_lang_lt spatialCoverage_lang_pl spatialCoverage_lang_ro spatialCoverage_lang_bg spatialCoverage_lang_hr spatialCoverage_lang_lv spatialCoverage_lang_ga spatialCoverage_lang_mt spatialCoverage_lang_et spatialCoverage_lang_eu</str>        
        <str name="f.where.qf">where_lang_undef where_lang_other where_lang_en where_lang_nl where_lang_fr where_lang_de where_lang_es where_lang_sv where_lang_it where_lang_fi where_lang_da where_lang_da where_lang_el where_lang_cs where_lang_sk where_lang_sl where_lang_pt where_lang_hu where_lang_lt where_lang_pl where_lang_ro where_lang_bg where_lang_hr where_lang_lv where_lang_ga where_lang_mt where_lang_et where_lang_eu</str>
        <str name="f.where_id.qf">providingCountry_id currentLocation_id spatialCoverage_id</str>
        
        <str name="f.dataProvider.qf">dataProvider_lang_undef dataProvider_lang_other dataProvider_lang_en dataProvider_lang_nl dataProvider_lang_fr dataProvider_lang_de dataProvider_lang_es dataProvider_lang_sv dataProvider_lang_it dataProvider_lang_fi dataProvider_lang_da dataProvider_lang_da dataProvider_lang_el dataProvider_lang_cs dataProvider_lang_sk dataProvider_lang_sl dataProvider_lang_pt dataProvider_lang_hu dataProvider_lang_lt dataProvider_lang_pl dataProvider_lang_ro dataProvider_lang_bg dataProvider_lang_hr dataProvider_lang_lv dataProvider_lang_ga dataProvider_lang_mt dataProvider_lang_et dataProvider_lang_eu</str>
        <str name="f.provider.qf">provider_lang_undef provider_lang_other provider_lang_en provider_lang_nl provider_lang_fr provider_lang_de provider_lang_es provider_lang_sv provider_lang_it provider_lang_fi provider_lang_da provider_lang_da provider_lang_el provider_lang_cs provider_lang_sk provider_lang_sl provider_lang_pt provider_lang_hu provider_lang_lt provider_lang_pl provider_lang_ro provider_lang_bg provider_lang_hr provider_lang_lv provider_lang_ga provider_lang_mt provider_lang_et provider_lang_eu</str>
        
        <str name="f.metadataText.qf">metadataText_lang_undef metadataText_lang_other metadataText_lang_en metadataText_lang_nl metadataText_lang_fr metadataText_lang_de metadataText_lang_es metadataText_lang_sv metadataText_lang_it metadataText_lang_fi metadataText_lang_da metadataText_lang_da metadataText_lang_el metadataText_lang_cs metadataText_lang_sk metadataText_lang_sl metadataText_lang_pt metadataText_lang_hu metadataText_lang_lt metadataText_lang_pl metadataText_lang_ro metadataText_lang_bg metadataText_lang_hr metadataText_lang_lv metadataText_lang_ga metadataText_lang_mt metadataText_lang_et metadataText_lang_eu</str>
        <str name="f.metadataText_id.qf">creator_id creatorProfession_id objectType_id subject_id medium_id format_id created_id issued_id temporalCoverage_id providingCountry_id currentLocation_id spatialCoverage_id provider_id dataProvider_id</str>
    </lst>
       <arr name="last-components">  
           <str>elevator</str>  
       </arr>  
  </requestHandler>

  <!-- mmarrero: adding just in case, but it should be implicitly added -->
  <requestHandler name="/replication" class="solr.ReplicationHandler"/>
  
  <!-- mmarrero: testing purposes -->
  <requestHandler name="/update" class="solr.UpdateRequestHandler"/>


<!-- mmarrero: basic handler to display elevation for testing purposes -->
  <requestHandler name="/elevate" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
    </lst>
    <arr name="last-components">
      <str>elevator</str>
    </arr>
  </requestHandler>

  <initParams path="/update/**">
    <lst name="defaults">
      <str name="update.chain">files-update-processor</str>
    </lst>
  </initParams>

  <initParams path="/update/**,/select,/elevate">
    <lst name="defaults">
      <str name="df">metadataText</str>
    </lst>
  </initParams>

  <!-- Search Components

       Search components are registered to SolrCore and used by
       instances of SearchHandler (which can access them by name)

       By default, the following components are available:

       <searchComponent name="query"     class="solr.QueryComponent" />
       <searchComponent name="facet"     class="solr.FacetComponent" />
       <searchComponent name="mlt"       class="solr.MoreLikeThisComponent" />
       <searchComponent name="highlight" class="solr.HighlightComponent" />
       <searchComponent name="stats"     class="solr.StatsComponent" />
       <searchComponent name="debug"     class="solr.DebugComponent" />

       Default configuration in a requestHandler would look like:

       <arr name="components">
         <str>query</str>
         <str>facet</str>
         <str>mlt</str>
         <str>highlight</str>
         <str>stats</str>
         <str>debug</str>
       </arr>

       If you register a searchComponent to one of the standard names,
       that will be used instead of the default.

       To insert components before or after the 'standard' components, use:

       <arr name="first-components">
         <str>myFirstComponentName</str>
       </arr>

       <arr name="last-components">
         <str>myLastComponentName</str>
       </arr>

       NOTE: The component registered with the name "debug" will
       always be executed after the "last-components"

     -->

  <!-- mmarrero: removing all components given as examples, check in default config in Solr 7.7.3 -->


  <!-- Query Elevation Component

       http://wiki.apache.org/solr/QueryElevationComponent

       a search component that enables you to configure the top
       results for a given query regardless of the normal lucene
       scoring.
    -->
  <searchComponent name="elevator" class="solr.QueryElevationComponent" >
    <!-- pick a fieldType to analyze queries -->
    <str name="queryFieldType">text_general</str>
    <str name="config-file">elevate.xml</str>
  </searchComponent>

 
  <!-- Highlighting Component

       http://wiki.apache.org/solr/HighlightingParameters
    -->
  <searchComponent class="solr.HighlightComponent" name="highlight">
    <highlighting>
      <!-- Configure the standard fragmenter -->
      <!-- This could most likely be commented out in the "default" case -->
      <fragmenter name="gap"
                  default="true"
                  class="solr.highlight.GapFragmenter">
        <lst name="defaults">
          <int name="hl.fragsize">100</int>
        </lst>
      </fragmenter>

      <!-- A regular-expression-based fragmenter
           (for sentence extraction)
        -->
      <fragmenter name="regex"
                  class="solr.highlight.RegexFragmenter">
        <lst name="defaults">
          <!-- slightly smaller fragsizes work better because of slop -->
          <int name="hl.fragsize">70</int>
          <!-- allow 50% slop on fragment sizes -->
          <float name="hl.regex.slop">0.5</float>
          <!-- a basic sentence pattern -->
          <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
        </lst>
      </fragmenter>

      <!-- Configure the standard formatter -->
      <formatter name="html"
                 default="true"
                 class="solr.highlight.HtmlFormatter">
        <lst name="defaults">
          <str name="hl.simple.pre"><![CDATA[<em>]]></str>
          <str name="hl.simple.post"><![CDATA[</em>]]></str>
        </lst>
      </formatter>

      <!-- Configure the standard encoder -->
      <encoder name="html"
               class="solr.highlight.HtmlEncoder" />

      <!-- Configure the standard fragListBuilder -->
      <fragListBuilder name="simple"
                       class="solr.highlight.SimpleFragListBuilder"/>

      <!-- Configure the single fragListBuilder -->
      <fragListBuilder name="single"
                       class="solr.highlight.SingleFragListBuilder"/>

      <!-- Configure the weighted fragListBuilder -->
      <fragListBuilder name="weighted"
                       default="true"
                       class="solr.highlight.WeightedFragListBuilder"/>

      <!-- default tag FragmentsBuilder -->
      <fragmentsBuilder name="default"
                        default="true"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <!--
        <lst name="defaults">
          <str name="hl.multiValuedSeparatorChar">/</str>
        </lst>
        -->
      </fragmentsBuilder>

      <!-- multi-colored tag FragmentsBuilder -->
      <fragmentsBuilder name="colored"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <lst name="defaults">
          <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
          <str name="hl.tag.post"><![CDATA[</b>]]></str>
        </lst>
      </fragmentsBuilder>

      <boundaryScanner name="default"
                       default="true"
                       class="solr.highlight.SimpleBoundaryScanner">
        <lst name="defaults">
          <str name="hl.bs.maxScan">10</str>
          <str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
        </lst>
      </boundaryScanner>

      <boundaryScanner name="breakIterator"
                       class="solr.highlight.BreakIteratorBoundaryScanner">
        <lst name="defaults">
          <!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
          <str name="hl.bs.type">WORD</str>
          <!-- language and country are used when constructing Locale object.  -->
          <!-- And the Locale object will be used when getting instance of BreakIterator -->
          <str name="hl.bs.language">en</str>
          <str name="hl.bs.country">US</str>
        </lst>
      </boundaryScanner>
    </highlighting>
  </searchComponent>

  <!-- Update Processors

       Chains of Update Processor Factories for dealing with Update
       Requests can be declared, and then used by name in Update
       Request Processors

       http://wiki.apache.org/solr/UpdateRequestProcessor

    -->

  <!-- Add unknown fields to the schema

       Field type guessing update processors that will
       attempt to parse string-typed field values as Booleans, Longs,
       Doubles, or Dates, and then add schema fields with the guessed
       field types. Text content will be indexed as "text_general" as
       well as a copy to a plain string version in *_str.

       These require that the schema is both managed and mutable, by
       declaring schemaFactory as ManagedIndexSchemaFactory, with
       mutable specified as true.

       See http://wiki.apache.org/solr/GuessingFieldTypes
    -->
  <!-- mmarrero: removed updateProcessors not used -->
  <updateProcessor class="solr.RemoveBlankFieldUpdateProcessorFactory" name="remove-blank"/>
  <updateProcessor class="solr.FieldNameMutatingUpdateProcessorFactory" name="field-name-mutating">
    <str name="pattern">[^\w-\.]</str>
    <str name="replacement">_</str>
  </updateProcessor>
  <updateProcessor class="solr.TimestampUpdateProcessorFactory" name="default-timestamp-update">
    <str name="fieldName">timestamp_update</str>
  </updateProcessor>
  <updateProcessor class="solr.TruncateFieldUpdateProcessorFactory" name="truncate-string">
    <str name="typeClass">solr.StrField</str>
    <int name="maxLength">8000</int>
  </updateProcessor>
  <updateProcessor class="solr.CloneFieldUpdateProcessorFactory" name="clone-fields-metadataText_lang">
    	<str name="pattern">^(title|description|creator|creatorProfession|objectType|subject|format|medium|created|issued|temporalCoverage|providingCountry|currentLocation|spatialCoverage|dataProvider|provider)_lang_(.*)$</str>
    	<str name="replacement">metadataText_lang_$2</str>     
  </updateProcessor>
  <updateProcessor class="solr.CloneFieldUpdateProcessorFactory" name="clone-fields-metadataText_contentCategory">
       <str name="source">contentCategory</str>
       <str name="dest">metadataText_lang_en</str>
  </updateProcessor>
  <updateProcessor class="solr.CloneFieldUpdateProcessorFactory" name="clone-fields-titlePlus">
  	<str name="pattern">^(title|description)_lang_(.*)$</str>
    <str name="replacement">titlePlus_lang_$2</str>
  </updateProcessor>
  <updateProcessor class="solr.CloneFieldUpdateProcessorFactory" name="clone-fields-who">
  	<str name="pattern">^(creator|creatorProfession)_lang_(.*)$</str>
    <str name="replacement">who_lang_$2</str>     
  </updateProcessor>
  <updateProcessor class="solr.CloneFieldUpdateProcessorFactory" name="clone-fields-what">
    	<str name="pattern">^(objectType|subject|format|medium)_lang_(.*)$</str>
    	<str name="replacement">what_lang_$2</str>   
  </updateProcessor>
  <updateProcessor class="solr.CloneFieldUpdateProcessorFactory" name="clone-fields-when">
  	<str name="pattern">^(created|issued|temporalCoverage)_lang_(.*)$</str>
    <str name="replacement">when_lang_$2</str>   
  </updateProcessor>
    <updateProcessor class="solr.CloneFieldUpdateProcessorFactory" name="clone-fields-where">
      	<str name="pattern">^(providingCountry|currentLocation|spatialCoverage)_lang_(.*)$</str>
    	<str name="replacement">where_lang_$2</str>
  </updateProcessor>
    
   <updateProcessor class="org.apache.solr.update.processor.UniqFieldsUpdateProcessorFactory" name="remove-duplicates-lang">
		<str name="fieldRegex">.*_lang_.*</str>
   </updateProcessor>
   <updateProcessor class="org.apache.solr.update.processor.UniqFieldsUpdateProcessorFactory" name="remove-duplicates-id">
		<str name="fieldRegex">.*_id</str>
   </updateProcessor>


  <!-- The update.autoCreateFields property can be turned to false to disable schemaless mode -->
  <!-- <updateRequestProcessorChain name="add-unknown-fields-to-the-schema" default="${update.autoCreateFields:true}"
           processor="uuid,remove-blank,field-name-mutating,parse-boolean,parse-long,parse-double,parse-date,add-schema-fields">
    <processor class="solr.LogUpdateProcessorFactory"/>
    <processor class="solr.DistributedUpdateProcessorFactory"/>
    <processor class="solr.RunUpdateProcessorFactory"/>
  </updateRequestProcessorChain>
-->
  <!-- mmarrero: custom processor -->
<updateRequestProcessorChain name="files-update-processor" processor="remove-blank,field-name-mutating,default-timestamp-update,truncate-string,clone-fields-titlePlus,clone-fields-who, clone-fields-what, clone-fields-where, clone-fields-when,remove-duplicates-lang, remove-duplicates-id, clone-fields-metadataText_lang,clone-fields-metadataText_contentCategory">
    <processor class="solr.LogUpdateProcessorFactory"/>
    <processor class="solr.DistributedUpdateProcessorFactory"/>
    <processor class="solr.RunUpdateProcessorFactory"/>
  </updateRequestProcessorChain>


  <!-- Deduplication

       An example dedup update processor that creates the "id" field
       on the fly based on the hash code of some other fields.  This
       example has overwriteDupes set to false since we are using the
       id field as the signatureField and Solr will maintain
       uniqueness based on that anyway.

    -->
  <!--
     <updateRequestProcessorChain name="dedupe">
       <processor class="solr.processor.SignatureUpdateProcessorFactory">
         <bool name="enabled">true</bool>
         <str name="signatureField">id</str>
         <bool name="overwriteDupes">false</bool>
         <str name="fields">name,features,cat</str>
         <str name="signatureClass">solr.processor.Lookup3Signature</str>
       </processor>
       <processor class="solr.LogUpdateProcessorFactory" />
       <processor class="solr.RunUpdateProcessorFactory" />
     </updateRequestProcessorChain>
    -->

  <!-- Language identification

       This example update chain identifies the language of the incoming
       documents using the langid contrib. The detected language is
       written to field language_s. No field name mapping is done.
       The fields used for detection are text, title, subject and description,
       making this example suitable for detecting languages form full-text
       rich documents injected via ExtractingRequestHandler.
       See more about langId at http://wiki.apache.org/solr/LanguageDetection
    -->
  <!--
   <updateRequestProcessorChain name="langid">
     <processor class="org.apache.solr.update.processor.TikaLanguageIdentifierUpdateProcessorFactory">
       <str name="langid.fl">text,title,subject,description</str>
       <str name="langid.langField">language_s</str>
       <str name="langid.fallback">en</str>
     </processor>
     <processor class="solr.LogUpdateProcessorFactory" />
     <processor class="solr.RunUpdateProcessorFactory" />
   </updateRequestProcessorChain>
  -->

  <!-- Script update processor

    This example hooks in an update processor implemented using JavaScript.

    See more about the script update processor at http://wiki.apache.org/solr/ScriptUpdateProcessor
  -->
  <!--
    <updateRequestProcessorChain name="script">
      <processor class="solr.StatelessScriptUpdateProcessorFactory">
        <str name="script">update-script.js</str>
        <lst name="params">
          <str name="config_param">example config parameter</str>
        </lst>
      </processor>
      <processor class="solr.RunUpdateProcessorFactory" />
    </updateRequestProcessorChain>
  -->

  <!-- Response Writers

       http://wiki.apache.org/solr/QueryResponseWriter

       Request responses will be written using the writer specified by
       the 'wt' request parameter matching the name of a registered
       writer.

       The "default" writer is the default and will be used if 'wt' is
       not specified in the request.
    -->
  <!-- The following response writers are implicitly configured unless
       overridden...
    -->
  <!--
     <queryResponseWriter name="xml"
                          default="true"
                          class="solr.XMLResponseWriter" />
     <queryResponseWriter name="json" class="solr.JSONResponseWriter"/>
     <queryResponseWriter name="python" class="solr.PythonResponseWriter"/>
     <queryResponseWriter name="ruby" class="solr.RubyResponseWriter"/>
     <queryResponseWriter name="php" class="solr.PHPResponseWriter"/>
     <queryResponseWriter name="phps" class="solr.PHPSerializedResponseWriter"/>
     <queryResponseWriter name="csv" class="solr.CSVResponseWriter"/>
     <queryResponseWriter name="schema.xml" class="solr.SchemaXmlResponseWriter"/>
    -->

  <queryResponseWriter name="json" class="solr.JSONResponseWriter">
    <!-- For the purposes of the tutorial, JSON responses are written as
     plain text so that they are easy to read in *any* browser.
     If you expect a MIME type of "application/json" just remove this override.
    -->
    <str name="content-type">text/plain; charset=UTF-8</str>
  </queryResponseWriter>

  <!-- XSLT response writer transforms the XML output by any xslt file found
       in Solr's conf/xslt directory.  Changes to xslt files are checked for
       every xsltCacheLifetimeSeconds.
    -->
  <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
    <int name="xsltCacheLifetimeSeconds">5</int>
  </queryResponseWriter>

  <!-- Query Parsers

       https://lucene.apache.org/solr/guide/query-syntax-and-parsing.html

       Multiple QParserPlugins can be registered by name, and then
       used in either the "defType" param for the QueryComponent (used
       by SearchHandler) or in LocalParams
    -->
  <!-- example of registering a query parser -->
  <!--
     <queryParser name="myparser" class="com.mycompany.MyQParserPlugin"/>
    -->

  <!-- Function Parsers

       http://wiki.apache.org/solr/FunctionQuery

       Multiple ValueSourceParsers can be registered by name, and then
       used as function names when using the "func" QParser.
    -->
  <!-- example of registering a custom function parser  -->
  <!--
     <valueSourceParser name="myfunc"
                        class="com.mycompany.MyValueSourceParser" />
    -->


  <!-- Document Transformers
       http://wiki.apache.org/solr/DocTransformers
    -->
  <!--
     Could be something like:
     <transformer name="db" class="com.mycompany.LoadFromDatabaseTransformer" >
       <int name="connection">jdbc://....</int>
     </transformer>

     To add a constant value to all docs, use:
     <transformer name="mytrans2" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
       <int name="value">5</int>
     </transformer>

     If you want the user to still be able to change it with _value:something_ use this:
     <transformer name="mytrans3" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
       <double name="defaultValue">5</double>
     </transformer>

      If you are using the QueryElevationComponent, you may wish to mark documents that get boosted.  The
      EditorialMarkerFactory will do exactly that:
     <transformer name="qecBooster" class="org.apache.solr.response.transform.EditorialMarkerFactory" />
    -->
</config>
